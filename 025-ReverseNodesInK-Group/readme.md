# [反转以K个为一组的节点](https://leetcode.com/problems/reverse-nodes-in-k-group/)

给一个链表，每次反转其中的k个节点，返回修改后的链表。

k是一个确定的整型，总是小于或等于链表长度。如果k不是链表长度的倍数，余下的那部分保持不动。

```
Example:
输入的链表: 1->2->3->4->5
k = 2时, 返回: 2->1->4->3->5
k = 3时, 返回: 3->2->1->4->5
```

注意：  
你的算法分配空间只能是个常数。  
不要去修改节点内的数值，仅仅是修改节点自身。

## 我的思路

这道题因为和上一题非常像，也是因为这个，我的思路基本拘泥在如果通过两两交换的方式反转K个节点。越陷越深，需要重复遍历节点多次，直到放弃这种想法，才突然想到：

- 锁定表头“head”，每次表头都往后移一个节点(即指向下一个的下一个)
- 而它的下一个节点移到头部，成为新表头
- 重复k-1次，完成反转

形象点来说：
```
原始：1->2->3->4->5
第一步：1->2->3->4->5
第二步：2->1->3->4->5
第三步：3->2->1->4->5
第四步：4->3->2->1->5
```

这是反转K个节点的方式，也是最基本的思路，现在还需要解决两个问题：

1. 如果K的值是链表长度的2倍以上呢？  
【答】：很简单，把上次反转后的末尾节点当作下次反转的头部，再递归调用一次函数即可。

2. 如果K的值不是链表长度的倍数呢？毕竟又不能事先知道链表长度。  
【答】：也很简单，先遍历，如果遍历到最后发现长度不是倍数，再重复递归一次(再反转回来)。

下面是C的实现：
```c
struct ListNode* reverseKGroup(struct ListNode* head, int k) {
  struct ListNode* node = head;
  for (int i = 1; i < k && node; i++) {
    struct ListNode* next = node->next;
    if (next == NULL) {
      // 当发现k不是链表长度的倍数时，把末尾反转复原
      head = reverseKGroup(head, i);
      return head;
    }

    node->next = next->next;
    next->next = head;
    head = next;
  }

  // 当还有剩余节点未遍历完时，继续递归
  if (node) {
    node->next = reverseKGroup(node->next, k);
  }

  return head;
}
```
- 时间复杂度：O(N)，N=(len(head))，基本上只会遍历链表一次，坏的情况下会重复遍历末尾一次。
- 空间复杂度：O(1)
